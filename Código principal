# -*- coding: utf-8 -*-
"""
Laboratorio 5 - Variabilidad de la Frecuencia Cardiaca (HRV)
Universidad Militar Nueva Granada

Fundamento teórico:
-------------------
El sistema nervioso autónomo (SNA) regula la frecuencia cardiaca mediante la acción del sistema simpático 
y parasimpático. La variabilidad de la frecuencia cardiaca (HRV) mide las fluctuaciones en los intervalos 
entre los latidos (intervalos R-R del ECG), reflejando la actividad del SNA.

Análisis:
- En el dominio del tiempo: se calculan la media y desviación estándar de los intervalos RR.
- En el dominio de la frecuencia: se utilizan herramientas como la Transformada Wavelet 
  para identificar la energía en bandas de baja frecuencia (LF: 0.04–0.15 Hz) y alta frecuencia (HF: 0.15–0.4 Hz),
  asociadas al control simpático y parasimpático respectivamente.
"""

# =========================
# LIBRERÍAS
# =========================
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, find_peaks
from scipy.interpolate import interp1d
import pywt
import xlsxwriter

# =========================
# PARÁMETROS
# =========================
RUTA_ARCHIVO = r"C:\Users\Gabriela\Documents\Laboratorio ultimo\señal ecg 1 Gaby.txt" # Cambia la ruta si es necesario
FS = 1000        # Frecuencia de muestreo de la señal ECG [Hz]
LOWCUT = 0.5     # Frecuencia de corte baja [Hz]
HIGHCUT = 40     # Frecuencia de corte alta [Hz]
ORDEN = 4        # Orden del filtro Butterworth

# =========================
# 1. LECTURA DE LA SEÑAL ECG
# =========================
def cargar_ecg(ruta):
    with open(ruta, 'r') as f:
        lineas = f.readlines()
    datos = [l.strip().split('\t') for l in lineas if not l.startswith('#')]
    datos = np.array(datos, dtype=float)
    ecg = datos[:, -1]  # Última columna (canal A1)
    return ecg

ecg = cargar_ecg(RUTA_ARCHIVO)
t = np.arange(len(ecg)) / FS

# =========================
# 2. FILTRADO PASO BANDA
# =========================
def butter_bandpass(lowcut, highcut, fs, order=4):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return b, a

def filtrar_senal(data, lowcut, highcut, fs, order=4):
    b, a = butter_bandpass(lowcut, highcut, fs, order)
    y = filtfilt(b, a, data)
    return y

ecg_filt = filtrar_senal(ecg, LOWCUT, HIGHCUT, FS, ORDEN)

# =========================
# 3. DETECCIÓN DE PICOS R
# =========================
picos, _ = find_peaks(ecg_filt, distance=FS*0.6, height=np.mean(ecg_filt)+0.3*np.std(ecg_filt))
RR_intervals = np.diff(picos) / FS  # Intervalos RR en segundos
tiempo_RR = np.cumsum(RR_intervals)

# =========================
# 4. PARÁMETROS HRV (DOMINIO DEL TIEMPO)
# =========================
RR_mean = np.mean(RR_intervals)
RR_std = np.std(RR_intervals)
bpm = 60 / RR_intervals

print(f"Media RR: {RR_mean:.3f} s")
print(f"Desviación estándar RR: {RR_std:.3f} s")
print(f"Frecuencia cardiaca promedio: {np.mean(bpm):.1f} bpm")

# =========================
# 5. ANÁLISIS DE FRECUENCIA (WAVELET + INTERPOLACIÓN)
# =========================
fs_rr = 4  # frecuencia de muestreo de la serie RR interpolada
tiempo_interp = np.arange(tiempo_RR[0], tiempo_RR[-1], 1/fs_rr)

# Interpolación cúbica de los intervalos RR
f_interp = interp1d(tiempo_RR, RR_intervals, kind='cubic', fill_value="extrapolate")
RR_interp = f_interp(tiempo_interp)

# Aplicar Wavelet Continua (CWT)
coef, freqs = pywt.cwt(RR_interp, np.arange(1, 128), 'morl', sampling_period=1/fs_rr)
potencia = np.abs(coef) ** 2

# Calcular energía por bandas LF y HF
LF_band = (freqs >= 0.04) & (freqs <= 0.15)
HF_band = (freqs > 0.15) & (freqs <= 0.4)

LF_power = np.mean(potencia[LF_band])
HF_power = np.mean(potencia[HF_band])
LF_HF_ratio = LF_power / HF_power

print(f"\nPotencia LF: {LF_power:.4f}")
print(f"Potencia HF: {HF_power:.4f}")
print(f"Relación LF/HF: {LF_HF_ratio:.3f}")

# =========================
# 6. GRAFICAR RESULTADOS
# =========================
plt.figure(figsize=(12, 10))

plt.subplot(4, 1, 1)
plt.plot(t, ecg, color='gray')
plt.title('Señal ECG Original')
plt.xlabel('Tiempo [s]')
plt.ylabel('Amplitud [mV]')

plt.subplot(4, 1, 2)
plt.plot(t, ecg_filt, 'b', label='ECG Filtrada')
plt.plot(picos/FS, ecg_filt[picos], 'r.', label='Picos R')
plt.title('ECG Filtrada y Detección de Picos R')
plt.xlabel('Tiempo [s]')
plt.ylabel('Amplitud')
plt.legend()

plt.subplot(4, 1, 3)
plt.plot(tiempo_RR, RR_intervals, 'g', label='RR original')
plt.plot(tiempo_interp, RR_interp, 'r--', label='RR interpolado')
plt.title('Serie de Intervalos RR (Original vs Interpolada)')
plt.xlabel('Tiempo [s]')
plt.ylabel('Duración [s]')
plt.legend()

plt.subplot(4, 1, 4)
plt.imshow(potencia, extent=[0, tiempo_interp[-1], freqs[-1], freqs[0]], 
           cmap='jet', aspect='auto')
plt.title('Espectrograma Wavelet (RR Interpolado)')
plt.xlabel('Tiempo [s]')
plt.ylabel('Frecuencia [Hz]')
plt.colorbar(label='Potencia')

plt.tight_layout()
plt.show()

# =========================
# 7. EXPORTAR RESULTADOS A EXCEL
# =========================
workbook = xlsxwriter.Workbook('Resultados_HRV_Gabriela.xlsx')
ws = workbook.add_worksheet('HRV')

ws.write('A1', 'Parámetro')
ws.write('B1', 'Valor')
ws.write('A2', 'Media RR (s)')
ws.write('B2', RR_mean)
ws.write('A3', 'Desviación estándar RR (s)')
ws.write('B3', RR_std)
ws.write('A4', 'Potencia LF')
ws.write('B4', LF_power)
ws.write('A5', 'Potencia HF')
ws.write('B5', HF_power)
ws.write('A6', 'Relación LF/HF')
ws.write('B6', LF_HF_ratio)

workbook.close()
print("\n✅ Resultados exportados a 'Resultados_HRV_Gabriela.xlsx'")
